[
    {
        "id": "8d2c5600e93d98d9",
        "type": "tab",
        "label": "SonnenBatterie Control",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "c303c08096ca06f0",
        "type": "subflow",
        "name": "SB Get Status",
        "info": "",
        "category": "",
        "in": [
            {
                "x": 60,
                "y": 80,
                "wires": [
                    {
                        "id": "e4ede092a5904284"
                    }
                ]
            }
        ],
        "out": [
            {
                "x": 760,
                "y": 80,
                "wires": [
                    {
                        "id": "96757557d82491fb",
                        "port": 0
                    }
                ]
            }
        ],
        "env": [],
        "meta": {},
        "color": "#3FADB5",
        "icon": "node-red/status.svg"
    },
    {
        "id": "eae36ce651e39938",
        "type": "subflow",
        "name": "SB Set Mode",
        "info": "",
        "category": "",
        "in": [
            {
                "x": 80,
                "y": 120,
                "wires": [
                    {
                        "id": "f79035cdbce7f16f"
                    }
                ]
            }
        ],
        "out": [],
        "env": [],
        "meta": {},
        "color": "#3FADB5",
        "icon": "node-red/status.svg"
    },
    {
        "id": "b54b23cb614d0af1",
        "type": "subflow",
        "name": "SB Charge Battery",
        "info": "",
        "category": "",
        "in": [
            {
                "x": 60,
                "y": 80,
                "wires": [
                    {
                        "id": "775aa518f64a102a"
                    }
                ]
            }
        ],
        "out": [],
        "env": [],
        "meta": {},
        "color": "#3FADB5",
        "icon": "node-red/status.svg"
    },
    {
        "id": "ef1fb0c70913c681",
        "type": "tibber-api-endpoint",
        "queryUrl": "https://api.tibber.com/v1-beta/gql",
        "feedConnectionTimeout": "30",
        "feedTimeout": "60",
        "queryRequestTimeout": "30",
        "name": "Markus"
    },
    {
        "id": "e4ede092a5904284",
        "type": "function",
        "z": "c303c08096ca06f0",
        "name": "Build Status Request",
        "func": "\nvar sonnen_ip = global.get(\"sonnen_api_ip\");\nvar sonnen_token = global.get(\"sonnen_api_token\");\n\nvar endpoint = \"/api/v2/status\"\n\nmsg.url = \"http://\" + sonnen_ip + endpoint;\nmsg.method = \"GET\"\nmsg.headers = {};\nmsg.headers['Auth-Token'] = sonnen_token;\n\n\n\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 240,
        "y": 80,
        "wires": [
            [
                "96757557d82491fb"
            ]
        ]
    },
    {
        "id": "96757557d82491fb",
        "type": "http request",
        "z": "c303c08096ca06f0",
        "name": "Generic HTTP Request",
        "method": "use",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 570,
        "y": 80,
        "wires": [
            []
        ]
    },
    {
        "id": "4b9735266375be0d",
        "type": "http request",
        "z": "eae36ce651e39938",
        "name": "Generic HTTP Request",
        "method": "use",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 950,
        "y": 120,
        "wires": [
            [
                "59f1fbcb4add51b0"
            ]
        ]
    },
    {
        "id": "d8db4521b6c0ebf9",
        "type": "function",
        "z": "eae36ce651e39938",
        "name": "Prepare Mode Set",
        "func": "var sonnen_ip = global.get(\"sonnen_api_ip\");\nvar sonnen_token = global.get(\"sonnen_api_token\");\n\nvar endpoint = \"/api/v2/configurations\"\n\nconst desiredMode = msg.batteryMode;\n\n\n\nif (typeof desiredMode != 'undefined') {\n    msg.url = \"http://\" + sonnen_ip + endpoint;\n    msg.method = \"PUT\"\n    msg.headers = {};\n    msg.headers['Auth-Token'] = sonnen_token;\n\n    msg.payload = {\"EM_OperatingMode\":desiredMode};\n\n    if (desiredMode == \"2\") {\n        //since the BatteryCharging status is unreliable/unpredictable, I have to set a flag in the global context.\n        global.set(\"isBatteryCharging\", false);\n    }\n\n    return msg;\n\n} else {\n\n    node.warn(\"Mode Set called without mode msg.batteryMode\");\n}\n\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 650,
        "y": 120,
        "wires": [
            [
                "4b9735266375be0d"
            ]
        ]
    },
    {
        "id": "f79035cdbce7f16f",
        "type": "function",
        "z": "eae36ce651e39938",
        "name": "checkIfRequestNeeded",
        "func": "const currentMode = msg.payload.OperatingMode;\nconst desiredMode = msg.batteryMode;\n\nif ((typeof desiredMode == 'undefined') || (typeof currentMode == 'undefined')){\n    node.warn(\"SBSetMode called with desiredMode \" + desiredMode + \"; currentMode \" + currentMode);\n} else {\n\n    if (currentMode != desiredMode) {\n        //we only need to handle this case. If desired == current, the flow stops (no msg returned)\n        //also means, no unneccessary SB API calls\n        return msg;\n    }\n\n}\n\n\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 120,
        "wires": [
            [
                "d8db4521b6c0ebf9"
            ]
        ]
    },
    {
        "id": "9041ec6f75969902",
        "type": "function",
        "z": "eae36ce651e39938",
        "name": "Prepare Charging=0 Watts",
        "func": "/*  Found out that the battery retains the last command in manual/API command. Could be a bug or a feature.\n    However, since the previous command was almost certainly \n    \n    \"/api/v2/setpoint/charge/\" + sonnen_watts;\n\n    We have to make sure it is set to 0, since we don't want to charge\n    Also, just to be on the safe side, will set the discharge also to 0 - so it is just idling, which is what we want in this case.\n    Until some other part of the flow wants it to charge or discharge (the latter simply by giving back control via \n    OperatingMode = \"2\").\n\n    */\n\n\nvar sonnen_ip = global.get(\"sonnen_api_ip\");\nvar sonnen_token = global.get(\"sonnen_api_token\");\n\nvar endpoint = \"/api/v2/setpoint/charge/0\";\n\nmsg.url = \"http://\" + sonnen_ip + endpoint;\nmsg.method = \"POST\"\nmsg.headers = {};\nmsg.headers['Auth-Token'] = sonnen_token;\nmsg.payload = {};\n\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1540,
        "y": 120,
        "wires": [
            [
                "119f89a55a89293c"
            ]
        ]
    },
    {
        "id": "119f89a55a89293c",
        "type": "http request",
        "z": "eae36ce651e39938",
        "name": "Generic HTTP Request",
        "method": "use",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 1850,
        "y": 120,
        "wires": [
            [
                "1bd0c7627951e848"
            ]
        ]
    },
    {
        "id": "1bd0c7627951e848",
        "type": "function",
        "z": "eae36ce651e39938",
        "name": "Prepare Discharging=0 Watts",
        "func": "/*  Just to be on the safe side, will set the discharge also to 0 - so it is just idling, which is what we want in this case.\n    Until some other part of the flow wants it to charge or discharge (the latter simply by giving back control via \n    OperatingMode = \"2\").\n\n    */\n\n\nvar sonnen_ip = global.get(\"sonnen_api_ip\");\nvar sonnen_token = global.get(\"sonnen_api_token\");\n\nvar endpoint = \"/api/v2/setpoint/discharge/0\";\n\nmsg.url = \"http://\" + sonnen_ip + endpoint;\nmsg.method = \"POST\"\nmsg.headers = {};\nmsg.headers['Auth-Token'] = sonnen_token;\nmsg.payload = {};\n\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2200,
        "y": 120,
        "wires": [
            [
                "e272e4a458855330"
            ]
        ]
    },
    {
        "id": "e272e4a458855330",
        "type": "http request",
        "z": "eae36ce651e39938",
        "name": "Generic HTTP Request",
        "method": "use",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 2510,
        "y": 120,
        "wires": [
            []
        ]
    },
    {
        "id": "59f1fbcb4add51b0",
        "type": "switch",
        "z": "eae36ce651e39938",
        "name": "OperatingMode == \"1\"?",
        "property": "payload.EM_OperatingMode",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "1",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 1250,
        "y": 120,
        "wires": [
            [
                "9041ec6f75969902"
            ]
        ]
    },
    {
        "id": "4cb01b9109bbbf49",
        "type": "function",
        "z": "b54b23cb614d0af1",
        "name": "Prepare Charging (OM=1)",
        "func": "var sonnen_ip = global.get(\"sonnen_api_ip\");\nvar sonnen_token = global.get(\"sonnen_api_token\");\n\nvar endpoint = \"/api/v2/configurations\"\n\nglobal.set(\"startChargeWh\", msg.payload.RemainingCapacity_Wh);\n\n\n\nmsg.url = \"http://\" + sonnen_ip + endpoint;\nmsg.method = \"PUT\"\nmsg.headers = {};\nmsg.headers['Auth-Token'] = sonnen_token;\nmsg.payload = {\"EM_OperatingMode\":\"1\"}\n\n\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 610,
        "y": 80,
        "wires": [
            [
                "edf31e9f60b417ae"
            ]
        ]
    },
    {
        "id": "edf31e9f60b417ae",
        "type": "http request",
        "z": "b54b23cb614d0af1",
        "name": "Generic HTTP Request",
        "method": "use",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 890,
        "y": 80,
        "wires": [
            [
                "a1bf0740af11e891"
            ]
        ]
    },
    {
        "id": "a1bf0740af11e891",
        "type": "function",
        "z": "b54b23cb614d0af1",
        "name": "Prepare Start Charging",
        "func": "var sonnen_ip = global.get(\"sonnen_api_ip\");\nvar sonnen_token = global.get(\"sonnen_api_token\");\nvar sonnen_watts = global.get(\"sonnen_charge_watts\");\n\nvar endpoint = \"/api/v2/setpoint/charge/\" + sonnen_watts;\n\nmsg.url = \"http://\" + sonnen_ip + endpoint;\nmsg.method = \"POST\"\nmsg.headers = {};\nmsg.headers['Auth-Token'] = sonnen_token;\nmsg.payload = {};\n\n//since the BatteryCharging status is unreliable/unpredictable, I have to set a flag in the global context.\n\nglobal.set(\"isBatteryCharging\", true);\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1170,
        "y": 80,
        "wires": [
            [
                "7594195ea36296d1"
            ]
        ]
    },
    {
        "id": "7594195ea36296d1",
        "type": "http request",
        "z": "b54b23cb614d0af1",
        "name": "Generic HTTP Request",
        "method": "use",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 1450,
        "y": 80,
        "wires": [
            [
                "842db788ce0f471f"
            ]
        ]
    },
    {
        "id": "842db788ce0f471f",
        "type": "switch",
        "z": "b54b23cb614d0af1",
        "name": "Charging ok?",
        "property": "payload",
        "propertyType": "msg",
        "rules": [
            {
                "t": "false"
            },
            {
                "t": "true"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 1690,
        "y": 80,
        "wires": [
            [
                "79512febc2a00a5c"
            ],
            [
                "55e5b79c18a638a8"
            ]
        ]
    },
    {
        "id": "79512febc2a00a5c",
        "type": "tibber-notify",
        "z": "b54b23cb614d0af1",
        "name": "Warning",
        "active": true,
        "apiEndpointRef": "ef1fb0c70913c681",
        "notifyTitle": "\"WARNING\"",
        "notifyMessage": "\"Battery won't charge\"",
        "notifyScreen": "",
        "x": 1880,
        "y": 60,
        "wires": []
    },
    {
        "id": "885810cbd4a4ef4d",
        "type": "subflow:c303c08096ca06f0",
        "z": "b54b23cb614d0af1",
        "name": "",
        "x": 520,
        "y": 240,
        "wires": [
            [
                "9b5de9f823cc9126"
            ]
        ]
    },
    {
        "id": "55e5b79c18a638a8",
        "type": "delay",
        "z": "b54b23cb614d0af1",
        "name": "",
        "pauseType": "delay",
        "timeout": "1",
        "timeoutUnits": "minutes",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 300,
        "y": 240,
        "wires": [
            [
                "885810cbd4a4ef4d"
            ]
        ]
    },
    {
        "id": "38b347bddf5e6590",
        "type": "function",
        "z": "b54b23cb614d0af1",
        "name": "nothingToDo",
        "func": "node.warn(\"Nothing To Do, already charging\");\nnode.warn(\"Current SoC: \" + msg.payload.USOC);\nnode.warn(\"Desired SoC: \" + global.get(\"sonnen_target_soc\"));\nnode.warn(\"Current Cost: \" + global.get(\"currentCheapHour\").total);\n\n",
        "outputs": 0,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 300,
        "y": 140,
        "wires": []
    },
    {
        "id": "7e16183d47f8f981",
        "type": "function",
        "z": "b54b23cb614d0af1",
        "name": "nothingToDo",
        "func": "node.warn(\"Charging has been stopped\");\nnode.warn(\"Current SoC: \" + msg.payload.USOC);\nnode.warn(\"Desired SoC: \" + global.get(\"sonnen_target_soc\"));\n\n\n",
        "outputs": 0,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1030,
        "y": 220,
        "wires": []
    },
    {
        "id": "4acf88cf4ee59011",
        "type": "switch",
        "z": "b54b23cb614d0af1",
        "name": "SoC < Desired SoC?",
        "property": "payload.USOC",
        "propertyType": "msg",
        "rules": [
            {
                "t": "gte",
                "v": "sonnen_target_soc",
                "vt": "global"
            },
            {
                "t": "lt",
                "v": "sonnen_target_soc",
                "vt": "global"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 1060,
        "y": 400,
        "wires": [
            [
                "58aed5301e38d673"
            ],
            [
                "55e5b79c18a638a8"
            ]
        ]
    },
    {
        "id": "f7d364f1fe8dda90",
        "type": "subflow:eae36ce651e39938",
        "z": "b54b23cb614d0af1",
        "name": "SB Stop Charging",
        "x": 1590,
        "y": 240,
        "wires": []
    },
    {
        "id": "58aed5301e38d673",
        "type": "function",
        "z": "b54b23cb614d0af1",
        "name": "calcChargedWh",
        "func": "const startedWithWh = global.get(\"startChargeWh\");\nconst stoppingWithWh = msg.payload.RemainingCapacity_Wh;\n\nconst chargedWh = stoppingWithWh - startedWithWh;\n\nvar chargeLogArray = global.get(\"chargeLog\");\nif (chargeLogArray == null) {\n    chargeLogArray = [];\n}\n\nvar lastCharge = {};\n\nlastCharge.timeStamp = new Date();\nlastCharge.cost = global.get(\"currentCheapHour\").total;\nlastCharge.wattHours = chargedWh;\n\nchargeLogArray.push(lastCharge);\n\nnode.warn(\"desired Soc reached, stopping\");\n\n\n\nglobal.set(\"chargeLog\", chargeLogArray);\n\n\nmsg.batteryMode = \"2\";\n\n\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1320,
        "y": 240,
        "wires": [
            [
                "f7d364f1fe8dda90"
            ]
        ]
    },
    {
        "id": "775aa518f64a102a",
        "type": "function",
        "z": "b54b23cb614d0af1",
        "name": "alreadyCharging?",
        "func": "/* ok, after having tested this for a couple of days, I can safely say that defining the status of\n\n\"is the battery charging\" by a combination of\n- operatingMode = \"1\" (battery is is manual/API mode)\n- isBatteryCharging\n\nis unreliable, I think mostly because the \"BatteryCharging\" status from the API is erroneous/unpredictable.\nSo, instead of relying on \n\nvar operatingMode = msg.payload.OperatingMode;\nvar isBatteryCharging = msg.payload.BatteryCharging;\n\nI will have to set a status in the global context and flip the switch on that.\n\n*/\n\nvar operatingMode = msg.payload.OperatingMode;\nvar isBatteryCharging = global.get(\"isBatteryCharging\");\n\nif (operatingMode == \"1\" && isBatteryCharging) {\n    //send to second output only, I'm already charging\n   \n    return [null, msg];\n\n} else {\n    //send to first output only, start charging\n    return [msg, null];\n}\n\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 270,
        "y": 80,
        "wires": [
            [
                "4cb01b9109bbbf49"
            ],
            [
                "38b347bddf5e6590"
            ]
        ]
    },
    {
        "id": "9b5de9f823cc9126",
        "type": "function",
        "z": "b54b23cb614d0af1",
        "name": "stillCharging?",
        "func": "/* ok, after having tested this for a couple of days, I can safely say that defining the status of\n\n\"is the battery charging\" by a combination of\n- operatingMode = \"1\" (battery is is manual/API mode)\n- isBatteryCharging\n\nis unreliable, I think mostly because the \"BatteryCharging\" status from the API is erroneous/unpredictable.\nSo, instead of relying on \n\nvar operatingMode = msg.payload.OperatingMode;\nvar isBatteryCharging = msg.payload.BatteryCharging;\n\nI will have to set a status in the global context and flip the switch on that.\n\n*/\n\nvar operatingMode = msg.payload.OperatingMode;\nvar isBatteryCharging = global.get(\"isBatteryCharging\");\n\n\nif (operatingMode == \"1\" && isBatteryCharging) {\n    //send to second output only, I'm still charging in manual/API mode\n   \n    return [null, msg];\n\n} else {\n    //send to first output only, charging has been stopped in main flow\n    return [msg, null];\n}\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 780,
        "y": 240,
        "wires": [
            [
                "7e16183d47f8f981"
            ],
            [
                "4acf88cf4ee59011"
            ]
        ]
    },
    {
        "id": "e130134e35ca8b0b",
        "type": "inject",
        "z": "8d2c5600e93d98d9",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "3600",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "",
        "payload": "{   viewer {     homes {       currentSubscription {         priceInfo {           today {             total             startsAt           }           tomorrow {             total             startsAt           }         }       }     }   } }",
        "payloadType": "str",
        "x": 130,
        "y": 240,
        "wires": [
            [
                "88db18caa0d4c682"
            ]
        ]
    },
    {
        "id": "88db18caa0d4c682",
        "type": "tibber-query",
        "z": "8d2c5600e93d98d9",
        "name": "GetPrices",
        "active": true,
        "apiEndpointRef": "ef1fb0c70913c681",
        "x": 280,
        "y": 240,
        "wires": [
            [
                "37ec5b24f80af82c"
            ]
        ]
    },
    {
        "id": "37ec5b24f80af82c",
        "type": "function",
        "z": "8d2c5600e93d98d9",
        "name": "getCheapestHours",
        "func": "const prices = msg.payload.viewer.homes[0].currentSubscription.priceInfo;\nconst today = prices.today;\nconst tomorrow = prices.tomorrow;\nconst userMaxPrice = flow.get(\"maxPrice\");\nconst lossFactor = flow.get(\"conversion_loss_factor\"); //e.g. 1.2 for 20% loss\nconst maxPriceFactor = 1 - (lossFactor - 1); \n//the above doesn't work above lossFactor > 2, but that would also mean 100% loss in conversion...\n//in that case, I'm happy you have a warm home because 100% of your power is converted into heat ;-)\n\n//tomorrow = [];\n\n/* First, let's get all available prices (today and if possible tomorrow).\n   \n   then, calc the average for the available series\n\n   then, reduce the list to all that are <factor> below the average AND below the maxPrice\n\n   then, sort by price and just take the first 5 (if available)... assuming that a full charge (SonnenBatterie10) will \n   take less than 2.5hrs\n\n   There surely are be better algorithms to calculate what a good charging price is, \n   suggestions are very welcome! \n   Create an issue or a discussion here: \n   https://github.com/orgs/sonnen-tools/discussions\n   https://github.com/sonnen-tools/node-red/issues \n\n   The \"shouldIBeCharging\" node takes the resulting list and just checks if the current timestamp is within\n   one of the \"cheapHours\"\n\n\n\n*/\n\nconst allPrices = today.concat(tomorrow);\nconst totalSum = allPrices.reduce((acc, obj) => acc + obj.total, 0);\nconst averagePrice = totalSum / allPrices.length; \n\nconst calculatedMaxPrice = averagePrice * maxPriceFactor;\n\nconst maxPrice = Math.min(calculatedMaxPrice, userMaxPrice); //use whichever is lower\n\n\nnode.warn(\"averagePrice: \" + averagePrice);\nnode.warn(\"minimumPrice (factored):\" + calculatedMaxPrice);\nnode.warn(\"userMaxPrice set to \" + userMaxPrice);\nnode.warn(\"maxPrice set to \" + maxPrice);\n\n\n//keep only those below or equal to maxPrice\nvar cheapHours = allPrices.filter(obj => obj.total <= maxPrice);\n\n// Sorting the array by the \"total\" property\ncheapHours.sort((a, b) => a.total - b.total);\n\n\n//store in flow context\n//memory is fine, since it will update on the next run\n\nflow.set(\"cheapHours\", cheapHours);\n\n\nmsg.cheapHours = cheapHours;\nmsg.maxPrice = maxPrice;\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 470,
        "y": 240,
        "wires": [
            [
                "cf3171b3c197749d"
            ]
        ]
    },
    {
        "id": "12460cf02b35326f",
        "type": "config",
        "z": "8d2c5600e93d98d9",
        "name": "Cheapest Hours Config",
        "properties": [
            {
                "p": "maxPrice",
                "pt": "flow",
                "to": "0.20",
                "tot": "num"
            },
            {
                "p": "conversion_loss_factor",
                "pt": "flow",
                "to": "1.0",
                "tot": "str"
            }
        ],
        "active": true,
        "x": 190,
        "y": 60,
        "wires": [],
        "info": "**flow.maxPrice**\n\nThe maximum price that would still be considered \"cheap\"\n\n**NOTE:** \nWe need to consider a conversion loss of roughly 20%,\nso setting to 0.25EUR/kWh effectively means using it at 0.25*1.2=0.30ct/kWh\n\nStill cheap compared to my previous contract (0.382)\n\n**flow.conversion_loss_factor**\n\n1.2 equals 20% conversion loss \n(Grid -> Inverter -> Battery -> Inverter -> Home Use)\nYour mileage may vary, but you can change it here.\nThis is used when determining if the battery should\nbe allowed to discharge\n(Doesn't make sense to discharge if the current grid cost is lower than\nwhat you charged for * <i>conversion_loss_factor</i>)"
    },
    {
        "id": "032dc4ca63696387",
        "type": "inject",
        "z": "8d2c5600e93d98d9",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "120",
        "crontab": "",
        "once": true,
        "onceDelay": "10",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 150,
        "y": 380,
        "wires": [
            [
                "5134b93e8d142a63"
            ]
        ]
    },
    {
        "id": "5134b93e8d142a63",
        "type": "function",
        "z": "8d2c5600e93d98d9",
        "name": "shouldIBeCharging?",
        "func": "const timeStamp = msg.payload;\n\nconst cheapHours = flow.get(\"cheapHours\");\n\n\n// Convert the timestamp to a Date object\nconst timestampDate = new Date(timeStamp);\n\n\n// Function to check if a startsAt date is within the full hour of a given date\nfunction isWithinFullHour(startsAtDate, referenceDate) {\n  return (\n    startsAtDate.getDate() === referenceDate.getDate() &&\n    startsAtDate.getHours() === referenceDate.getHours()\n  );\n}\n\nvar matchingObject = cheapHours.find(item => {\n  const startsAtDate = new Date(item.startsAt);\n  return isWithinFullHour(startsAtDate, timestampDate);\n});\n\nif (typeof matchingObject === 'undefined') {\n  matchingObject = null;\n}\n\n// Output the result\nnode.warn(\"Is within timestamp full hour:\" + (matchingObject !== null));\nnode.warn(matchingObject);\n\nif (matchingObject !== null) {\n  global.set(\"currentCheapHour\", matchingObject);\n}\n\nif (matchingObject !== null) {\n   node.status({ fill: \"green\", shape: \"dot\", text: \"yes - charge\" });\n   return [ msg, null ];\n} else {\n   node.status({ fill: \"red\", shape: \"dot\", text: \"no - don't charge\" });\n   return [ null, msg ];\n}\n\n\n\n\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 400,
        "y": 380,
        "wires": [
            [
                "4a32a6e6d05dea24"
            ],
            [
                "7d45042d33a188fb"
            ]
        ]
    },
    {
        "id": "d149fbdaf11a8469",
        "type": "function",
        "z": "8d2c5600e93d98d9",
        "name": "convertToEpoch",
        "func": "const timeString = msg.payload;\n\n\n// Create a Date object from the time string\nconst dateObject = new Date(timeString);\n\n// Get the numerical epoch value (timestamp)\nconst timestamp = dateObject.getTime();\n\nmsg.payload = timestamp;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 520,
        "wires": [
            [
                "5134b93e8d142a63"
            ]
        ]
    },
    {
        "id": "3c6fd3c2fdafe496",
        "type": "inject",
        "z": "8d2c5600e93d98d9",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "v": "",
                "vt": "date"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "2023-12-31T07:00:00.000+01:00",
        "payloadType": "str",
        "x": 130,
        "y": 520,
        "wires": [
            [
                "d149fbdaf11a8469"
            ]
        ]
    },
    {
        "id": "6047656486a171a2",
        "type": "config",
        "z": "8d2c5600e93d98d9",
        "name": "SonnenBatterie Config",
        "properties": [
            {
                "p": "sonnen_api_ip",
                "pt": "global",
                "to": "192.168.2.108",
                "tot": "str"
            },
            {
                "p": "sonnen_api_token",
                "pt": "global",
                "to": "215ddea7-dff9-421b-8744-ee2504f9ec0e",
                "tot": "str"
            },
            {
                "p": "sonnen_target_soc",
                "pt": "global",
                "to": "56",
                "tot": "num"
            },
            {
                "p": "sonnen_charge_watts",
                "pt": "global",
                "to": "4500",
                "tot": "num"
            },
            {
                "p": "sonnen_discharge_control",
                "pt": "flow",
                "to": "true",
                "tot": "bool"
            }
        ],
        "active": true,
        "x": 480,
        "y": 60,
        "wires": []
    },
    {
        "id": "4a32a6e6d05dea24",
        "type": "subflow:c303c08096ca06f0",
        "z": "8d2c5600e93d98d9",
        "name": "SB Get Status",
        "x": 760,
        "y": 320,
        "wires": [
            [
                "c5f7a979efb1d7d1"
            ]
        ]
    },
    {
        "id": "c5f7a979efb1d7d1",
        "type": "switch",
        "z": "8d2c5600e93d98d9",
        "name": "SoC < Desired SoC?",
        "property": "payload.USOC",
        "propertyType": "msg",
        "rules": [
            {
                "t": "lt",
                "v": "sonnen_target_soc",
                "vt": "global"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 1030,
        "y": 320,
        "wires": [
            [
                "cd59768b95503089"
            ]
        ]
    },
    {
        "id": "7d45042d33a188fb",
        "type": "subflow:c303c08096ca06f0",
        "z": "8d2c5600e93d98d9",
        "name": "SB Get Status",
        "x": 760,
        "y": 480,
        "wires": [
            [
                "9a6cf1e9bd4b4d6b"
            ]
        ]
    },
    {
        "id": "cd59768b95503089",
        "type": "subflow:b54b23cb614d0af1",
        "z": "8d2c5600e93d98d9",
        "name": "SB Charge",
        "x": 1290,
        "y": 320,
        "wires": []
    },
    {
        "id": "5763e1f16f68be6d",
        "type": "function",
        "z": "8d2c5600e93d98d9",
        "name": "calcChargedWh",
        "func": "const startedWithWh = global.get(\"startChargeWh\");\nconst stoppingWithWh = msg.payload.RemainingCapacity_Wh;\n\nconst chargedWh = stoppingWithWh - startedWithWh;\n\n\n\n\n\nvar chargeLogArray = global.get(\"chargeLog\");\nif (chargeLogArray == null) {\n    chargeLogArray = [];\n}\n\nvar lastCharge = {};\n\nlastCharge.timeStamp = new Date();\nlastCharge.cost = global.get(\"currentCheapHour\").total\nlastCharge.wattHours = chargedWh;\n\nchargeLogArray.push(lastCharge);\n\nglobal.set(\"chargeLog\", chargeLogArray);\n\n\n\n\n\n\n\n\n\nmsg.batteryMode = \"2\";\n\n\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1260,
        "y": 440,
        "wires": [
            [
                "6147a605469482ae"
            ]
        ]
    },
    {
        "id": "34bc8f672e3abdf8",
        "type": "inject",
        "z": "8d2c5600e93d98d9",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 760,
        "y": 60,
        "wires": [
            [
                "06e26d32f8706c95"
            ]
        ]
    },
    {
        "id": "06e26d32f8706c95",
        "type": "change",
        "z": "8d2c5600e93d98d9",
        "name": "Cleanup Global Context",
        "rules": [
            {
                "t": "delete",
                "p": "chargeLog",
                "pt": "global"
            },
            {
                "t": "delete",
                "p": "currentCheapHour",
                "pt": "global"
            },
            {
                "t": "delete",
                "p": "lastChargedPrice",
                "pt": "global"
            },
            {
                "t": "delete",
                "p": "lastChargedWh",
                "pt": "global"
            },
            {
                "t": "delete",
                "p": "startChargeWh",
                "pt": "global"
            },
            {
                "t": "delete",
                "p": "tibber_tomorrow",
                "pt": "global"
            },
            {
                "t": "delete",
                "p": "tibber_today",
                "pt": "global"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1070,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "cf3171b3c197749d",
        "type": "function",
        "z": "8d2c5600e93d98d9",
        "name": "storeAllPrices",
        "func": "var prices = msg.payload.viewer.homes[0].currentSubscription.priceInfo;\nvar today = prices.today;\nvar tomorrow = prices.tomorrow;\nvar tomorrow_high = {};\nvar tomorrow_low = {};\nvar tomorrow_avg = 0.0;\nconst cheapHours = msg.cheapHours; \nconst maxPrice = msg.maxPrice;\n\n\nglobal.set(\"tibber_today\", today);\n\nvar ctx_tomorrow = global.get(\"tibber_tomorrow\");\nif (typeof ctx_tomorrow === 'undefined') {\n  ctx_tomorrow = [];\n}\n\nglobal.set(\"tibber_tomorrow\", tomorrow);\n\nif (ctx_tomorrow.length == 0 && tomorrow.length > 0) {\n\n  node.warn(\"new prices are here\");\n  // Find entry with the lowest \"total\" value\n  tomorrow_low = tomorrow.reduce((min, obj) => (obj.total < min.total ? obj : min), tomorrow[0]);\n\n  // Find entry with the highest \"total\" value\n  tomorrow_high = tomorrow.reduce((max, obj) => (obj.total > max.total ? obj : max), tomorrow[0]);\n\n  const totalSum = tomorrow.reduce((sum, obj) => sum + obj.total, 0);\n  tomorrow_avg = totalSum / tomorrow.length; //should always be 24, but...whatever.\n\n\n  node.warn(\"Lowest Price: \" + tomorrow_low.total + \" at \" + tomorrow_low.startsAt);\n  node.warn(\"Highest Price: \" + tomorrow_high.total + \" at \" + tomorrow_high.startsAt);\n  node.warn(\"Average: \" + tomorrow_avg);\n\n  msg.payload.title = \"Updated prices for tomorrow!\";\n  msg.payload.screen = \"HOME\";\n\n  var message = \"Low: \" + tomorrow_low.total + \"\\nHigh: \" + tomorrow_high.total + \"\\nAverage: \" + tomorrow_avg;\n\n  message = message + \"\\nMaxPrice for charging: \" + maxPrice;\n  message = message + \"\\n\" + cheapHours.length + \" slots for charging identified\";\n\n  msg.payload.message = message;\n\n  \n  return [ msg, null ];\n} else {\n  return [ null, msg ];\n}\n\n\n\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 680,
        "y": 240,
        "wires": [
            [
                "8c0165d4b3c2cf06"
            ],
            []
        ]
    },
    {
        "id": "8c0165d4b3c2cf06",
        "type": "tibber-notify",
        "z": "8d2c5600e93d98d9",
        "name": "New Price Notify",
        "active": true,
        "apiEndpointRef": "ef1fb0c70913c681",
        "notifyTitle": "",
        "notifyMessage": "",
        "notifyScreen": "",
        "x": 920,
        "y": 200,
        "wires": []
    },
    {
        "id": "458aea83fb3ba99d",
        "type": "switch",
        "z": "8d2c5600e93d98d9",
        "name": "DischargeControl on?",
        "property": "sonnen_discharge_control",
        "propertyType": "flow",
        "rules": [
            {
                "t": "true"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 1280,
        "y": 540,
        "wires": [
            [
                "0d1bbec1c374b622"
            ]
        ]
    },
    {
        "id": "0d1bbec1c374b622",
        "type": "function",
        "z": "8d2c5600e93d98d9",
        "name": "calculateDischargeCost",
        "func": "/*    \n    This control flow aims at avoiding battery discharge when the price is low anyway (lower than the \n    average cost of what we charged * conversion_loss_factor) \n*/\n\nvar charges = global.get(\"chargeLog\");\n\nif (typeof charges === 'undefined'){\n  charges = [];\n}\n\n/*  \n    Discarding any charge events older than 24 hours (assuming we have probably used them), to keep the average price\n    of stored energy somewhat accurate.\n    This is \"brute force\", I know - but keeping track of how much has actually been used between charge events\n    *might* be possible, but is currently a bit beyond the scope of this iteration.\n    Also, this doesn't take into account that any PV surplus stored will significantly lower the average!\n    During Summer, when the PV is constantly filling the battery, it will be best to set the\n    \"sonnen_discharge_control\" config variable to false, allowing the SonnenBatterie to manage itself.\n\n    If you have suggestions on how this could be implemented, feel free to open an issue or leave a comment\n    https://github.com/orgs/sonnen-tools/discussions\n    https://github.com/sonnen-tools/node-red/issues \n\n*/\n\n//using this for the average calculation\nconst aDayAgo = new Date();\naDayAgo.setHours(aDayAgo.getHours() - 24);\n\n\nconst currentCharges = charges.filter(obj => new Date(obj.timeStamp) > aDayAgo);\n\n\n\n\n\n\ncurrentCharges.forEach(obj => {\n  obj.total = obj.cost * obj.wattHours;\n});\n\n\nconst totalSum = currentCharges.reduce((acc, obj) => acc + obj.total, 0);\nconst wattHoursSum = currentCharges.reduce((acc, obj) => acc + obj.wattHours, 0);\n\nconst averageCost = totalSum / wattHoursSum;\nnode.warn(\"avg: \" + averageCost);\n\n\n\nmsg.batteryCharges = currentCharges;\nmsg.batteryAverageCost = averageCost;\n\n\n\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1530,
        "y": 540,
        "wires": [
            [
                "e349bd68cf117405"
            ]
        ]
    },
    {
        "id": "9a6cf1e9bd4b4d6b",
        "type": "function",
        "z": "8d2c5600e93d98d9",
        "name": "amICharging?",
        "func": "/* ok, after having tested this for a couple of days, I can safely say that defining the status of\n\n\"is the battery charging\" by a combination of\n- operatingMode = \"1\" (battery is is manual/API mode)\n- isBatteryCharging\n\nis unreliable, I think mostly because the \"BatteryCharging\" status from the API is erroneous/unpredictable.\nSo, instead of relying on \n\nvar operatingMode = msg.payload.OperatingMode;\nvar isBatteryCharging = msg.payload.BatteryCharging;\n\nI will have to set a status in the global context and flip the switch on that.\n\n*/\n\nvar operatingMode = msg.payload.OperatingMode;\nvar isBatteryCharging = global.get(\"isBatteryCharging\");\n\n\nif (operatingMode == \"1\" && isBatteryCharging) {\n    //send to first output only\n    return [msg, null];\n\n} else {\n    //send to second output only\n    return [null, msg];\n}\n\n\n\n\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1020,
        "y": 480,
        "wires": [
            [
                "5763e1f16f68be6d"
            ],
            [
                "458aea83fb3ba99d"
            ]
        ]
    },
    {
        "id": "e349bd68cf117405",
        "type": "function",
        "z": "8d2c5600e93d98d9",
        "name": "shouldIDischarge?",
        "func": "//get the current Tibber Price and compare to what we charged the battery with * lossFactor\n//if we current prices are cheaper, we should stop the battery from discharging\n\n\nconst today = global.get(\"tibber_today\");\n\n\nconst lossFactor = flow.get(\"conversion_loss_factor\"); //e.g. 1.2 for 20% loss\nconst batteryPrice = msg.batteryAverageCost;\nconst factoredBatteryAverage = batteryPrice * lossFactor;\nconst stateOfCharge = msg.payload.USOC; \n\n\nconst now = new Date();\n\n// Function to check if a startsAt date is within the full hour of a given date\nfunction isWithinFullHour(startsAtDate, referenceDate) {\n  return (\n    startsAtDate.getDate() === referenceDate.getDate() &&\n    startsAtDate.getHours() === referenceDate.getHours()\n  );\n}\n\nconst matchingPrice = today.find(item => {\n  const startsAtDate = new Date(item.startsAt);\n  return isWithinFullHour(startsAtDate, now);\n});\n\nconst currentPrice = matchingPrice.total;\n\nnode.warn(\"SoC\" + stateOfCharge);\nif (stateOfCharge == 0) {\n\n  //battery is empty, so we can clean up the charge log\n  const emptyChargeLog = [];\n  global.set(\"chargeLog\", emptyChargeLog);\n\n  node.status({ fill: \"yellow\", shape: \"dot\", text: \"Battery empty\" });\n  //do nothing, send to 2nd output\n  return [null, msg];\n}\n\n\n\nif (currentPrice > factoredBatteryAverage){\n/* The Battery should be allowed to discharge (normal mode, OM=2), since \n   the current Tibber Price is higher than the adjusted average of the battery\n\n*/\n  node.status({ fill: \"green\", shape: \"dot\", text: \"yes - Tibber: \" + currentPrice + \" battery: \" + factoredBatteryAverage });\n  msg.batteryMode = \"2\";\n  \n} else {\n/* The Battery should not be allowed to discharge, \n   since the current Tibber Price is below the factored average of what's in the battery \n   (setting to manual mode, so now it is neither charging nor discharging until we tell it to)\n   ATTENTION: This also means that when there is PV surplus, it won't be stored.\n              That's why we probably shouldn't be using this (set \"sonnen_discharge_control\" to false)\n              during summer...\n              Idea for later - add some more functionality to watch PV surplus according to API for a while,\n              then act on it.\n*/\n  node.status({ fill: \"red\", shape: \"dot\", text: \"no - Tibber: \" + currentPrice + \" battery: \" + factoredBatteryAverage });\n  msg.batteryMode = \"1\";\n  \n}\n\nreturn [msg, null];\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1770,
        "y": 540,
        "wires": [
            [
                "79bb5d8a31bfa3b4"
            ],
            []
        ]
    },
    {
        "id": "79bb5d8a31bfa3b4",
        "type": "subflow:eae36ce651e39938",
        "z": "8d2c5600e93d98d9",
        "name": "",
        "x": 1990,
        "y": 520,
        "wires": []
    },
    {
        "id": "6147a605469482ae",
        "type": "subflow:eae36ce651e39938",
        "z": "8d2c5600e93d98d9",
        "name": "SB Stop Charging",
        "x": 1490,
        "y": 440,
        "wires": []
    },
    {
        "id": "b4c0dd3b94b310d2",
        "type": "inject",
        "z": "8d2c5600e93d98d9",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 760,
        "y": 100,
        "wires": [
            [
                "e9b6ae202d801ef8"
            ]
        ]
    },
    {
        "id": "e9b6ae202d801ef8",
        "type": "change",
        "z": "8d2c5600e93d98d9",
        "name": "",
        "rules": [
            {
                "t": "delete",
                "p": "tibber_today",
                "pt": "global"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1070,
        "y": 100,
        "wires": [
            []
        ]
    }
]